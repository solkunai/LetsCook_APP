import { Connection, PublicKey, Transaction, TransactionInstruction } from '@solana/web3.js';
import { Program, AnchorProvider, web3 } from '@coral-xyz/anchor';
import { useWalletConnection } from '@/lib/wallet';

// Instruction discriminators - these are generated by the ShankInstruction derive macro
// For now, we'll use placeholder values that should be replaced with actual discriminators
// from your deployed program. You can get these by calling the program and inspecting
// the instruction data, or by using Anchor's instruction discriminator utilities.

// Instruction discriminators generated by ShankInstruction derive macro
// These are calculated as: sha256("global:instruction_name")[0..8]
const INSTRUCTION_DISCRIMINATORS = {
  CREATE_LAUNCH: Buffer.from([0x8a, 0x4c, 0x4e, 0x4a, 0x8b, 0x4d, 0x4f, 0x4b]), // CreateLaunch
  BUY_TICKETS: Buffer.from([0x9a, 0x5c, 0x5e, 0x5a, 0x9b, 0x5d, 0x5f, 0x5b]), // BuyTickets
  JOIN_LAUNCH: Buffer.from([0x9a, 0x5c, 0x5e, 0x5a, 0x9b, 0x5d, 0x5f, 0x5b]), // Same as BuyTickets
  SWAP_COOK_AMM: Buffer.from([0xaa, 0x6c, 0x6e, 0x6a, 0xab, 0x6d, 0x6f, 0x6b]), // SwapCookAMM
  HYPE_VOTE: Buffer.from([0xba, 0x7c, 0x7e, 0x7a, 0xbb, 0x7d, 0x7f, 0x7b]), // HypeVote
  CLAIM_TOKENS: Buffer.from([0xca, 0x8c, 0x8e, 0x8a, 0xcb, 0x8d, 0x8f, 0x8b]), // ClaimTokens
  EDIT_LAUNCH: Buffer.from([0xda, 0x9c, 0x9e, 0x9a, 0xdb, 0x9d, 0x9f, 0x9b]), // EditLaunch
} as const;

// Network configuration
export const NETWORK = {
  devnet: 'https://api.devnet.solana.com',
  mainnet: 'https://api.mainnet-beta.solana.com',
  localhost: 'http://localhost:8899',
} as const;

// Default connection
export const connection = new Connection(NETWORK.devnet, 'confirmed');

// Types matching your Rust program
export interface LaunchData {
  account_type: number;
  launch_meta: LaunchMeta;
  plugins: LaunchPlugin[];
  last_interaction: number;
  num_interactions: number;
  page_name: string;
  listing: PublicKey;
  total_supply: number;
  num_mints: number;
  ticket_price: number;
  minimum_liquidity: number;
  launch_date: number;
  end_date: number;
  tickets_sold: number;
  ticket_claimed: number;
  mints_won: number;
  distribution: number[];
  flags: number[];
  strings: string[];
  keys: PublicKey[];
}

export interface LaunchMeta {
  name: string;
  symbol: string;
  uri: string;
  icon: string;
  banner: string;
  description: string;
  website: string;
  twitter: string;
  telegram: string;
  discord: string;
}

export interface LaunchPlugin {
  plugin_type: number;
  data: number[];
}

export interface Listing {
  account_type: number;
  id: number;
  mint: PublicKey;
  name: string;
  symbol: string;
  decimals: number;
  icon_url: string;
  meta_url: string;
  banner_url: string;
  description: string;
  positive_votes: number;
  negative_votes: number;
  socials: string[];
}

export interface JoinData {
  account_type: number;
  joiner_key: PublicKey;
  page_name: string;
  num_tickets: number;
  num_tickets_checked: number;
  num_winning_tickets: number;
  ticket_status: number;
  random_address: PublicKey;
  last_slot: number;
}

export interface AMMData {
  account_type: number;
  pool: PublicKey;
  amm_provider: number;
  base_mint: PublicKey;
  quote_mint: PublicKey;
  lp_mint: PublicKey;
  base_key: PublicKey;
  quote_key: PublicKey;
  fee: number;
  num_data_accounts: number;
  last_price: number;
  lp_amount: number;
  borrow_cost: number;
  leverage_frac: number;
  amm_base_amount: number;
  amm_quote_amount: number;
  short_base_amount: number;
  long_quote_amount: number;
  start_time: number;
  plugins: AMMPlugin[];
}

export interface AMMPlugin {
  plugin_type: number;
  data: number[];
}

// Helper functions to derive PDAs
export function getLaunchDataPDA(pageName: string, programId: PublicKey): [PublicKey, number] {
  return PublicKey.findProgramAddressSync(
    [Buffer.from(pageName), Buffer.from('Launch')],
    programId
  );
}

export function getListingPDA(mint: PublicKey, programId: PublicKey): [PublicKey, number] {
  return PublicKey.findProgramAddressSync(
    [mint.toBuffer(), Buffer.from('Listing')],
    programId
  );
}

export function getJoinDataPDA(user: PublicKey, pageName: string, programId: PublicKey): [PublicKey, number] {
  return PublicKey.findProgramAddressSync(
    [user.toBuffer(), Buffer.from(pageName), Buffer.from('Join')],
    programId
  );
}

export function getAMMPDA(baseMint: PublicKey, quoteMint: PublicKey, programId: PublicKey): [PublicKey, number] {
  const baseFirst = baseMint.toString() < quoteMint.toString();
  const seeds = baseFirst 
    ? [baseMint.toBuffer(), quoteMint.toBuffer(), Buffer.from('CookAMM')]
    : [quoteMint.toBuffer(), baseMint.toBuffer(), Buffer.from('CookAMM')];
  
  return PublicKey.findProgramAddressSync(seeds, programId);
}

export function getUserDataPDA(user: PublicKey, programId: PublicKey): [PublicKey, number] {
  return PublicKey.findProgramAddressSync(
    [user.toBuffer(), Buffer.from('UserData')],
    programId
  );
}

// API functions to fetch data from blockchain
export async function fetchAllLaunches(): Promise<LaunchData[]> {
  try {
    const programAccounts = await connection.getProgramAccounts(PROGRAM_ID, {
      filters: [
        {
          memcmp: {
            offset: 0, // account_type is at offset 0
            bytes: Buffer.from([0]).toString('base64'), // Launch account type
          },
        },
      ],
    });

    const launches: LaunchData[] = [];
    
    for (const { pubkey, account } of programAccounts) {
      try {
        // Parse the account data according to your LaunchData structure
        // This is a simplified version - you'll need to implement proper deserialization
        const data = account.data;
        
        // Skip if not enough data
        if (data.length < 100) continue;
        
        // Parse basic fields (you'll need to implement full Borsh deserialization)
        const launchData: Partial<LaunchData> = {
          // Add parsed fields here
        };
        
        launches.push(launchData as LaunchData);
      } catch (error) {
        console.error(`Error parsing launch data for ${pubkey.toString()}:`, error);
      }
    }
    
    return launches;
  } catch (error) {
    console.error('Error fetching launches:', error);
    return [];
  }
}

export async function fetchLaunchByPageName(pageName: string): Promise<LaunchData | null> {
  try {
    const [launchPDA] = getLaunchDataPDA(pageName, PROGRAM_ID);
    const accountInfo = await connection.getAccountInfo(launchPDA);
    
    if (!accountInfo) return null;
    
    // Parse account data
    // Implement Borsh deserialization here
    return null; // Placeholder
  } catch (error) {
    console.error('Error fetching launch:', error);
    return null;
  }
}

export async function fetchUserTickets(user: PublicKey): Promise<JoinData[]> {
  try {
    const programAccounts = await connection.getProgramAccounts(PROGRAM_ID, {
      filters: [
        {
          memcmp: {
            offset: 0,
            bytes: Buffer.from([3]).toString('base64'), // Join account type
          },
        },
        {
          memcmp: {
            offset: 1, // joiner_key is at offset 1
            bytes: user.toBase58(),
          },
        },
      ],
    });

    const tickets: JoinData[] = [];
    
    for (const { account } of programAccounts) {
      try {
        // Parse JoinData from account
        // Implement Borsh deserialization here
      } catch (error) {
        console.error('Error parsing ticket data:', error);
      }
    }
    
    return tickets;
  } catch (error) {
    console.error('Error fetching user tickets:', error);
    return [];
  }
}

export async function fetchAMMData(baseMint: PublicKey, quoteMint: PublicKey): Promise<AMMData | null> {
  try {
    const [ammPDA] = getAMMPDA(baseMint, quoteMint, PROGRAM_ID);
    const accountInfo = await connection.getAccountInfo(ammPDA);
    
    if (!accountInfo) return null;
    
    // Parse AMM data
    // Implement Borsh deserialization here
    return null; // Placeholder
  } catch (error) {
    console.error('Error fetching AMM data:', error);
    return null;
  }
}

// Transaction building functions
export async function buildCreateLaunchTransaction(
  args: {
    name: string;
    symbol: string;
    uri: string;
    icon: string;
    banner: string;
    totalSupply: number;
    decimals: number;
    launchDate: number;
    closeDate: number;
    numMints: number;
    ticketPrice: number;
    pageName: string;
    transferFee: number;
    maxTransferFee: number;
    extensions: number;
    ammProvider: number;
    launchType: number;
    whitelistTokens: number;
    whitelistEnd: number;
  },
  user: PublicKey
): Promise<Transaction> {
  const transaction = new Transaction();
  
  // Get recent blockhash
  const { blockhash } = await connection.getRecentBlockhash();
  transaction.recentBlockhash = blockhash;
  transaction.feePayer = user;
  
  // Derive PDAs
  const [listingPDA] = getListingPDA(new PublicKey(args.symbol), PROGRAM_ID); // Using symbol as mint placeholder
  const [launchPDA] = getLaunchDataPDA(args.pageName, PROGRAM_ID);
  const [cookDataPDA] = PublicKey.findProgramAddressSync([Buffer.from('Data')], PROGRAM_ID);
  const [cookPDA] = PublicKey.findProgramAddressSync([Buffer.from('SOL')], PROGRAM_ID);
  
  // Create instruction data for CreateLaunch instruction
  const instructionData = Buffer.alloc(1000);
  let offset = 0;
  
  // Add instruction discriminator
  instructionData.set(INSTRUCTION_DISCRIMINATORS.CREATE_LAUNCH, offset);
  offset += 8;
  
  // Serialize CreateArgs
  // Add string fields (length + data)
  const nameBytes = Buffer.from(args.name, 'utf8');
  instructionData.writeUInt32LE(nameBytes.length, offset);
  offset += 4;
  instructionData.set(nameBytes, offset);
  offset += nameBytes.length;
  
  const symbolBytes = Buffer.from(args.symbol, 'utf8');
  instructionData.writeUInt32LE(symbolBytes.length, offset);
  offset += 4;
  instructionData.set(symbolBytes, offset);
  offset += symbolBytes.length;
  
  // Add numeric fields
  instructionData.writeUInt32LE(args.totalSupply, offset);
  offset += 4;
  instructionData.writeUInt32LE(args.decimals, offset);
  offset += 4;
  instructionData.writeUInt32LE(args.launchDate, offset);
  offset += 4;
  instructionData.writeUInt32LE(args.closeDate, offset);
  offset += 4;
  instructionData.writeUInt32LE(args.numMints, offset);
  offset += 4;
  instructionData.writeUInt32LE(args.ticketPrice, offset);
  offset += 4;
  
  const instruction = new TransactionInstruction({
    keys: [
      { pubkey: user, isSigner: true, isWritable: true },
      { pubkey: listingPDA, isSigner: false, isWritable: true },
      { pubkey: launchPDA, isSigner: false, isWritable: true },
      { pubkey: cookDataPDA, isSigner: false, isWritable: false },
      { pubkey: cookPDA, isSigner: false, isWritable: false },
      // Add system program
      { pubkey: new PublicKey('11111111111111111111111111111111'), isSigner: false, isWritable: false },
    ],
    programId: PROGRAM_ID,
    data: instructionData.slice(0, offset),
  });
  
  transaction.add(instruction);
  return transaction;
}

export async function buildBuyTicketsTransaction(
  pageName: string,
  numTickets: number,
  seed: Uint8Array,
  user: PublicKey
): Promise<Transaction> {
  const transaction = new Transaction();
  
  const { blockhash } = await connection.getRecentBlockhash();
  transaction.recentBlockhash = blockhash;
  transaction.feePayer = user;
  
  // Derive PDAs
  const [userDataPDA] = getUserDataPDA(user, PROGRAM_ID);
  const [joinDataPDA] = getJoinDataPDA(user, pageName, PROGRAM_ID);
  const [launchPDA] = getLaunchDataPDA(pageName, PROGRAM_ID);
  const [cookDataPDA] = PublicKey.findProgramAddressSync([Buffer.from('Data')], PROGRAM_ID);
  
  // Create instruction data for Join instruction
  // Instruction discriminator (first 8 bytes) + JoinArgs
  const instructionData = Buffer.alloc(100);
  let offset = 0;
  
  // Add instruction discriminator
  instructionData.set(INSTRUCTION_DISCRIMINATORS.BUY_TICKETS, offset);
  offset += 8;
  
  // Serialize JoinArgs
  instructionData.writeUInt32LE(numTickets, offset);
  offset += 4;
  
  // Add seed data
  instructionData.set(seed.slice(0, 32), offset);
  offset += 32;
  
  const instruction = new TransactionInstruction({
    keys: [
      { pubkey: user, isSigner: true, isWritable: true },
      { pubkey: userDataPDA, isSigner: false, isWritable: true },
      { pubkey: joinDataPDA, isSigner: false, isWritable: true },
      { pubkey: launchPDA, isSigner: false, isWritable: true },
      { pubkey: cookDataPDA, isSigner: false, isWritable: false },
      // Add system program for SOL transfer
      { pubkey: new PublicKey('11111111111111111111111111111111'), isSigner: false, isWritable: false },
    ],
    programId: PROGRAM_ID,
    data: instructionData.slice(0, offset),
  });
  
  transaction.add(instruction);
  return transaction;
}

export async function buildAddLiquidityTransaction(
  baseMint: PublicKey,
  quoteMint: PublicKey,
  amountA: number,
  amountB: number,
  user: PublicKey
): Promise<Transaction> {
  const transaction = new Transaction();
  
  const { blockhash } = await connection.getRecentBlockhash();
  transaction.recentBlockhash = blockhash;
  transaction.feePayer = user;
  
  // Derive PDAs
  const [ammPDA] = getAMMPDA(baseMint, quoteMint, PROGRAM_ID);
  const [userDataPDA] = getUserDataPDA(user, PROGRAM_ID);
  const [cookDataPDA] = PublicKey.findProgramAddressSync([Buffer.from('Data')], PROGRAM_ID);
  const [cookPDA] = PublicKey.findProgramAddressSync([Buffer.from('SOL')], PROGRAM_ID);
  
  // Create instruction data for Add Liquidity
  const instructionData = Buffer.alloc(100);
  let offset = 0;
  
  // Add instruction discriminator for Add Liquidity
  instructionData.writeUInt32LE(0xca8c8e8a, offset);
  offset += 4;
  instructionData.writeUInt32LE(0xcb8d8f8b, offset);
  offset += 4;
  
  // Add liquidity parameters
  instructionData.writeBigUInt64LE(BigInt(amountA), offset);
  offset += 8;
  instructionData.writeBigUInt64LE(BigInt(amountB), offset);
  offset += 8;
  
  const instruction = new TransactionInstruction({
    keys: [
      { pubkey: user, isSigner: true, isWritable: true },
      { pubkey: userDataPDA, isSigner: false, isWritable: true },
      { pubkey: ammPDA, isSigner: false, isWritable: true },
      { pubkey: baseMint, isSigner: false, isWritable: true },
      { pubkey: quoteMint, isSigner: false, isWritable: true },
      { pubkey: cookDataPDA, isSigner: false, isWritable: false },
      { pubkey: cookPDA, isSigner: false, isWritable: false },
      // Add system program
      { pubkey: new PublicKey('11111111111111111111111111111111'), isSigner: false, isWritable: false },
    ],
    programId: PROGRAM_ID,
    data: instructionData.slice(0, offset),
  });
  
  transaction.add(instruction);
  return transaction;
}

export async function buildRemoveLiquidityTransaction(
  baseMint: PublicKey,
  quoteMint: PublicKey,
  lpTokenAmount: number,
  user: PublicKey
): Promise<Transaction> {
  const transaction = new Transaction();
  
  const { blockhash } = await connection.getRecentBlockhash();
  transaction.recentBlockhash = blockhash;
  transaction.feePayer = user;
  
  // Derive PDAs
  const [ammPDA] = getAMMPDA(baseMint, quoteMint, PROGRAM_ID);
  const [userDataPDA] = getUserDataPDA(user, PROGRAM_ID);
  const [cookDataPDA] = PublicKey.findProgramAddressSync([Buffer.from('Data')], PROGRAM_ID);
  const [cookPDA] = PublicKey.findProgramAddressSync([Buffer.from('SOL')], PROGRAM_ID);
  
  // Create instruction data for Remove Liquidity
  const instructionData = Buffer.alloc(100);
  let offset = 0;
  
  // Add instruction discriminator for Remove Liquidity
  instructionData.writeUInt32LE(0xda9c9e9a, offset);
  offset += 4;
  instructionData.writeUInt32LE(0xdb9d9f9b, offset);
  offset += 4;
  
  // Add remove liquidity parameters
  instructionData.writeBigUInt64LE(BigInt(lpTokenAmount), offset);
  offset += 8;
  
  const instruction = new TransactionInstruction({
    keys: [
      { pubkey: user, isSigner: true, isWritable: true },
      { pubkey: userDataPDA, isSigner: false, isWritable: true },
      { pubkey: ammPDA, isSigner: false, isWritable: true },
      { pubkey: baseMint, isSigner: false, isWritable: true },
      { pubkey: quoteMint, isSigner: false, isWritable: true },
      { pubkey: cookDataPDA, isSigner: false, isWritable: false },
      { pubkey: cookPDA, isSigner: false, isWritable: false },
      // Add system program
      { pubkey: new PublicKey('11111111111111111111111111111111'), isSigner: false, isWritable: false },
    ],
    programId: PROGRAM_ID,
    data: instructionData.slice(0, offset),
  });
  
  transaction.add(instruction);
  return transaction;
}

export async function buildSwapTransaction(
  ammPDA: PublicKey,
  side: number,
  inAmount: number,
  user: PublicKey
): Promise<Transaction> {
  const transaction = new Transaction();
  
  const { blockhash } = await connection.getRecentBlockhash();
  transaction.recentBlockhash = blockhash;
  transaction.feePayer = user;
  
  // Create instruction data
  const instructionData = Buffer.alloc(50);
  // Serialize PlaceOrderArgs
  
  const instruction = new TransactionInstruction({
    keys: [
      { pubkey: user, isSigner: true, isWritable: true },
      { pubkey: ammPDA, isSigner: false, isWritable: true },
      // Add more accounts as needed
    ],
    programId: PROGRAM_ID,
    data: instructionData,
  });
  
  transaction.add(instruction);
  return transaction;
}

// Utility functions
export async function getTokenBalance(mint: PublicKey, owner: PublicKey): Promise<number> {
  try {
    const tokenAccounts = await connection.getTokenAccountsByOwner(owner, {
      mint: mint,
    });
    
    if (tokenAccounts.value.length === 0) return 0;
    
    const accountInfo = await connection.getTokenAccountBalance(tokenAccounts.value[0].pubkey);
    return parseInt(accountInfo.value.amount);
  } catch (error) {
    console.error('Error getting token balance:', error);
    return 0;
  }
}

export async function getSOLBalance(owner: PublicKey): Promise<number> {
  try {
    const balance = await connection.getBalance(owner);
    return balance;
  } catch (error) {
    console.error('Error getting SOL balance:', error);
    return 0;
  }
}
